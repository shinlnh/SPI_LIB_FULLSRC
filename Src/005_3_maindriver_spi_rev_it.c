/*
 * 005_2maindriver_spi.c
 *
 *  Created on: Nov 16, 2024
 *      Author: Shin
 */


/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*SPI1-NSS : PA4
 *SPI1-SCK : PA5
 *SPI1-MISO: PA6
 *SPI1-MOSI: PA7
 *ALT5
 * */

#include <stdint.h>
#include <stdio.h>
#include "string.h"
#include "stm32f429xx_gpio_driver.h"
#include "stm32f429xx_spi_driver.h"

#define MAX_LEN 	500
SPI_Config_t pSPIConfig;
char RcvBuff[MAX_LEN];
volatile char ReadByte;

volatile uint8_t rcvStop = 0;
/*This flag will be set in the interrupt handler of the Arduino interrupt GPIO*/
volatile uint8_t dataAvailable = 0;
void delay(void);
void LNH_GPIOCLK(GPIO_RegDef_t*pGPIOx, uint8_t EN_DI);
void LNH_SPICLK(SPI_RegDef_t* pSPIx, uint8_t EN_DI);
void LNH_SPIGPIO_Init(void);
void LNH_SPI_Init(void);
void LNH_SPI_ENABLE(SPI_RegDef_t* pSPIx, uint8_t EN_DI);

int main(void)
{
	uint8_t dummy = 0xFF;
	//char user_data[] = "Hello World";
	LNH_GPIOCLK(GPIOA,1);
	LNH_GPIOCLK(GPIOD,1);
	LNH_SPICLK(SPI1,1);


	LNH_SPIGPIO_Init();

	LNH_SPI_Init();
	__LNH_SPI_IRQ_ITConfig(IRQ_NO_SPI1 ,EN);
	while(1)
	{
		//while (!__LNH_GPIO_ReadPin(GPIOA, GPIO_PIN_0));

		//delay();

		LNH_SPI_ENABLE(SPI1,1);
		rcvStop = 0;
		while(!dataAvailable); // wait till data available interrupt from tranmission device

		 __LNH_GPIO_IRQ_ITConfig(IRQ_NO_EXTI9_5 ,DI);

		//First send length information
		//uint8_t datalength = strlen(user_data);
		//__LNH_SPI_SendData(SPI1,&datalength,1);

		//__LNH_SPI_SendData(SPI1,(uint8_t*)user_data, strlen(user_data));

		//while(__LNH_SPI_BSY(SPI1));

		//LNH_SPI_ENABLE(SPI1,0);
		while(!rcvStop)
		{
			/*fetch the data from the SPI peripherals byte by byte in interrupt mode*/
			while (__LNH_SPI_SendDataIT(&pSPIConfig,&dummy,1) == SPI_BUSY_IN_TX);
			while (__LNH_SPI_ReceiveDataIT(&pSPIConfig,&ReadByte,1) == SPI_BUSY_IN_RX);
		}
		//Confirm SPI is not busy
		while (__LNH_SPI_GetFlagStatus(SPI1,SPI_BUSY_FLAG));

		//Disable the SPI peripherals
		LNH_SPICLK(SPI2,0);

		printf("Rcvd data = %s\n",RcvBuff);

		dataAvailable = 0;

		__LNH_GPIO_IRQ_ITConfig(IRQ_NO_EXTI9_5,EN);
	}

	return 0;
}


void LNH_GPIOCLK(GPIO_RegDef_t*pGPIOx, uint8_t EN_DI)
{
	__LNH_GPIO_PeriClockControl(pGPIOx,EN_DI);
}
void LNH_SPICLK(SPI_RegDef_t* pSPIx, uint8_t EN_DI)
{

	__LNH_SPI_PeriClockControl(pSPIx,EN_DI);
}

void LNH_SPIGPIO_Init(void)
{

	GPIO_Config_t pGPIOConfig0;
	pGPIOConfig0.pGPIOx = GPIOD;
	pGPIOConfig0.GPIO_PIN = GPIO_PIN_6;
	pGPIOConfig0.GPIO_MODE = GPIO_MODE_IT;
	pGPIOConfig0.GPIO_SPEED = GPIO_SPEED_MS;
	pGPIOConfig0.GPIO_PUPD = GPIO_PUPD_NP;
	pGPIOConfig0.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig0.GPIO_AF = 0;
	pGPIOConfig0.pEXTI = EXTI;
	pGPIOConfig0.pSYSCFG = SYSCFG;
	pGPIOConfig0.EXTI_ENDI = EXTI_EN;
	pGPIOConfig0.EXTI_TRIGGER = 0;
	__LNH_GPIO_Init(&pGPIOConfig0);
	//NSS : PA4
	GPIO_Config_t pGPIOConfig1;
	pGPIOConfig1.pGPIOx = GPIOA;
	pGPIOConfig1.GPIO_PIN = GPIO_PIN_4;
	pGPIOConfig1.GPIO_MODE = GPIO_MODE_ALT;
	pGPIOConfig1.GPIO_SPEED = GPIO_SPEED_HS;
	pGPIOConfig1.GPIO_PUPD = GPIO_PUPD_NP;
	pGPIOConfig1.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig1.GPIO_AF = GPIO_AF_5;
	pGPIOConfig1.pEXTI = EXTI;
	pGPIOConfig1.pSYSCFG = SYSCFG;
	pGPIOConfig1.EXTI_ENDI = EXTI_DI;
	pGPIOConfig1.EXTI_TRIGGER = EXTI_IT_RT;
	__LNH_GPIO_Init(&pGPIOConfig1);

	//SCK : PA5
	GPIO_Config_t pGPIOConfig2;
	pGPIOConfig2.pGPIOx = GPIOA;
	pGPIOConfig2.GPIO_PIN = GPIO_PIN_5;
	pGPIOConfig2.GPIO_MODE = GPIO_MODE_ALT;
	pGPIOConfig2.GPIO_SPEED = GPIO_SPEED_HS;
	pGPIOConfig2.GPIO_PUPD = GPIO_PUPD_NP;
	pGPIOConfig2.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig2.GPIO_AF = GPIO_AF_5;
	pGPIOConfig2.pEXTI = EXTI;
	pGPIOConfig2.pSYSCFG = SYSCFG;
	pGPIOConfig2.EXTI_ENDI = EXTI_DI;
	pGPIOConfig2.EXTI_TRIGGER = EXTI_IT_RT;
	__LNH_GPIO_Init(&pGPIOConfig2);

	//MISO : PA6
	GPIO_Config_t pGPIOConfig3;
	pGPIOConfig3.pGPIOx = GPIOA;
	pGPIOConfig3.GPIO_PIN = GPIO_PIN_6;
	pGPIOConfig3.GPIO_MODE = GPIO_MODE_ALT;
	pGPIOConfig3.GPIO_SPEED = GPIO_SPEED_HS;
	pGPIOConfig3.GPIO_PUPD = GPIO_PUPD_NP;
	pGPIOConfig3.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig3.GPIO_AF = GPIO_AF_5;
	pGPIOConfig3.pEXTI = EXTI;
	pGPIOConfig3.pSYSCFG = SYSCFG;
	pGPIOConfig3.EXTI_ENDI = EXTI_DI;
	pGPIOConfig3.EXTI_TRIGGER = EXTI_IT_RT;
	__LNH_GPIO_Init(&pGPIOConfig3);

	//MOSI : PA7

	GPIO_Config_t pGPIOConfig4;
	pGPIOConfig4.pGPIOx = GPIOA;
	pGPIOConfig4.GPIO_PIN = GPIO_PIN_7;
	pGPIOConfig4.GPIO_MODE = GPIO_MODE_ALT;
	pGPIOConfig4.GPIO_SPEED = GPIO_SPEED_HS;
	pGPIOConfig4.GPIO_PUPD = GPIO_PUPD_NP;
	pGPIOConfig4.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig4.GPIO_AF = GPIO_AF_5;
	pGPIOConfig4.pEXTI = EXTI;
	pGPIOConfig4.pSYSCFG = SYSCFG;
	pGPIOConfig4.EXTI_ENDI = EXTI_DI;
	pGPIOConfig4.EXTI_TRIGGER = EXTI_IT_RT;
	__LNH_GPIO_Init(&pGPIOConfig4);

	//BTN
	GPIO_Config_t pGPIOConfig5;
	pGPIOConfig5.pGPIOx = GPIOA;
	pGPIOConfig5.GPIO_PIN = GPIO_PIN_0;
	pGPIOConfig5.GPIO_MODE = GPIO_MODE_IN;
	pGPIOConfig5.GPIO_SPEED = GPIO_SPEED_MS;
	pGPIOConfig5.GPIO_PUPD = GPIO_PUPD_PD;
	pGPIOConfig5.GPIO_OTYPE = GPIO_OTYPE_PP;
	pGPIOConfig5.GPIO_AF = 0;
	pGPIOConfig5.pEXTI = EXTI;
	pGPIOConfig5.pSYSCFG = SYSCFG;
	pGPIOConfig5.EXTI_ENDI = EXTI_EN;
	pGPIOConfig5.EXTI_TRIGGER = EXTI_IT_RT;

	__LNH_GPIO_Init(&pGPIOConfig5);
}

void LNH_SPI_Init(void)
{

	pSPIConfig.pSPIx = SPI1;
	pSPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	pSPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	pSPIConfig.SPI_SCLKSpeed = SPI_SCLK_SPEED_DIV2; //8MHz
	pSPIConfig.SPI_DFF = SPI_DFF_8BITS;
	pSPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	pSPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	pSPIConfig.SPI_SSM = SPI_SSM_HW;
	pSPIConfig.SPI_FUNC = SPI_FUNC_MT;
	__LNH_SPI_Init(&pSPIConfig);

}
void LNH_SPI_ENABLE(SPI_RegDef_t* pSPIx, uint8_t EN_DI)
{
	 __LNH_SPI_PeripheralENDI(pSPIx,EN_DI);
}
void delay()
{

		for(uint32_t i=0;i<500000/2;i++);

}
/*Run when a data byte is received from the peripherals over SPI*/
void SPI1_IRQHandler(void)
{
	__LNH_SPI_IRQHanding(&pSPIConfig);
}

void __LNH_ApplicationEventCallback(SPI_Config_t* pSPIConfig,uint8_t AppEv)
{
	static uint32_t i = 0;
	/*In the Rx complete event, copy data in to rcv buffer. '\0' indicates end of message(rcvStop =1) */
	if (AppEv == SPI_EVENT_RX_CMPLT)
	{
		RcvBuff[i++] = ReadByte;
		if( ReadByte == '0' || i == MAX_LEN)
		{
			rcvStop = 1;
			RcvBuff[i-1] = '\0';
			i = 0;

		}
	}
}
/*Slave data available interrupt handler
 */
void EXTI9_5_IRQHandler(void)
{
	__LNH_GPIO_IRQHanding(GPIO_PIN_6);
	dataAvailable = 1;
}





